\subsection{Flow: A data-type agonistic data-flow based architecture}
At Ascent's core is a simple data-flow library, called Flow, that
composes and executes filters, the basic unit of execution in Ascent.
%
Flow is an evolution of a Python data-flow network
~\cite{flow_reference}, but unlike its ancestor, Flow is a C++
library.
%
Flow supports composing and executing directed acyclic graphs
(DAGs) composed of filters~\cite{LarsenAscent}.

There are three components to Flow:
\begin{itemize}
  \item \textbf{Registry}: manages the lifetime of intermediate filter results
  \item \textbf{Graph}: contains the filter graph and manages the adding of filters
  \item \textbf{Workspace}: container for both the registry and filter graph
\end{itemize}

\paragraph{Registry}
The registry is a key-value data store used to manage the intermediate
results of filters inside the data-flow network.
%
Keys within the registry are reference counted, and data contained
inside the registry is deleted when the reference counts reach zero.
%
While the data associated with a key can be a pointer to any type,
the majority of the data stored in the registry are Conduit nodes
or VTK-m data sets.

\paragraph{Graph}
The graph interface supports main operations: adding filters
and connecting filters together.
%

\paragraph{Workspace}
The workspace is a container for both the graph and the registry,
and the workspace is responsible for creating an execution for plan
for the DAG.
%
\fix{Cyrus: make sure these words are true.}
Flow uses a topological sort to ensure proper filter execution order,
tracks all intermediate results, and provides basic memory management capabilities.
%
Multiple workspaces can co-exist, and in fact, Ascent uses a Flow workspace
to evaluate expressions within the Ascent runtime.

\paragraph{Flow Filters}
Flow filters are the basic unit of execution inside of Ascent, and
almost all functionality inside of Ascent is implemented as a Flow filter.
%
Filters declare an interface, i.e., how many inputs a filter has and
if there is an output.
%
Inside Ascent, typical inputs and outputs are data sets.
%
Additionally, filters are passed a set of parameters inside of a Conduit
node.
%
Filters are registered with the workspace and can then be added to the
graph by name.


\subsection{Runtime}
The Ascent runtime exists on top of Flow and is resposible for
handling applicaiton-facing API calls and translating user-facing
``actions`` into a data-flow network.
%
Built-in functionality is registered internally with the Ascent runtime,
but externally defined filters can also be registered with registered
with Ascent, allowing for simulations to execute custom code within Ascent.
%
Filters can be registers as either a ``transform'' or a ``extract''.
%
Transforms are intermediate nodes in the data-flow network and transform
data sets.
%
An example of transforms is a iso-contour, where a volume is converted
into a surface.
%
Extracts are terminal nodes in the data-flow network, and extracts
are the main mechanism for software interoperability inside of Ascent.

\subsection{Node-level parallelism? Words to describe VTK-m and other components}

Component based architecture? Components include VTK-m, Devil Ray, perhaps things like ADIOS and other extracts.

\subsection{Distributed-Memory Execution}

\subsection{Extracts: optional python environment}
I feel like this subsection is about the ways to get to other things.
