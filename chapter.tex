%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{Ascent: A Flyweight In Situ Library for Exascale Simulations}
\label{ascent} % Always give a unique label
% use \chaptermark{}
% to alter or adjust the chapter heading in the running head

\abstract*{
In situ coupling poses a unique set of challenges to the design of analysis and
visualization infrastructures.
%
When running with a simulation, resources, such as time and memory are constrained.
%
As simulation applications port to accelerator-based HPC architectures, so
must our analysis tools.
%
Further, integrating into a simulation's build system adds additional complexity
becomes difficult with more dependencies.
%
Our current community tools were not designed with these set of issues in mind.
%
Ascent is an emerging is situ analysis and visualization infrastructure that
addresses these challenges.
%
From Ascent's inception, we have targeted in situ use cases and many-core
architectures.
%
In this paper, we will discuss in detail Ascent's design considerations, data and control interfaces, system architecture, and success stories.
}

This chapter describes the Ascent library for in situ visualization
and analysis.
%
Ascent was designed to deliver on two goals which are often in tension:
 (1) minimize encumbrance on simulation codes that incorporate Ascent,
i.e., a ``flyweight'' design, and
(2) deliver diverse and powerful capabilities,
especially for modern supercomputers.
%
In addition, Ascent is built for production use by computational
simulation codes --- it has documentation,
examples, engages in modern software engineering practices, etc.

In terms of flyweight design, Ascent aims to minimize
execution time, memory usage, binary size, and integration effort.
%
The first two, execution time and memory usage, benefit from directly
incorporating VTK-m~\cite{Moreland:CGA2016} into Ascent.
%
For minizing memory,
VTK-m's data model supports many array layouts (e.g., row major versus
column major, array of structures versus structures of arrays)
in a zero-copy manner.
%
In most cases, the majority of the memory needed by Ascent is only for
storing intermediate results.
%
To minimize execution time,
VTK-m provides native support for many-core architectures,
including NVIDIA GPUs, various Intel architectures,
and planned support for AMD GPUs.
%
Further, Ascent complements VTK-m's shared-memory parallelism with
its own layer for distributed-memory parallelism based on the
Message Passing Interface (MPI) library.
%
In all, Ascent is able to perform its algorithms very quickly,
since it can make full use of the underlying hardware architecture.
%
\fix{Statement about binary size.}
%
Finally, Ascent's API was designed to be simple to learn,
easy to integrate for novice users, and small in overall code size.
%
Integrations can be as short as ten lines of code.
%
This topic is explored more in \S\ref{sec:API}.

In terms of delivering diverse and powerful capabilities,
Ascent employs multiple approaches:
integration with many technologies,
supporting both visualization and analysis routines,
algorithms specifically designed for in situ processing,
and providing support for modern supercomputers.
%
Ascent's strongest component for delivering capabilities is likely
through integrating many additional technologies.
%
In terms of integrations with other visualization and I/O products,
Ascent is able to produce Cinema and HDF5 files, interact with
ADIOS and Catalyst, and, as previously mentioned, utilizes VTK-m
directly for much of its data model and visualization algorithms.
%
It also provides many options for integration, including
bindings
for controlling Ascent with  C, C++, Python and Fortan.
%
Further, it provides options for controlling Ascent via its code API,
via YAML files (which can be changed dynamically at runtime), and via
a Jupyter notebook integration \cite{CyrusISAV}.
%
Finally, Ascent is able to integrate arbitrary code, including
Python scripts and C/C++ code.
%
This pathway also enables access to
machine learning infrastructures, such as TensorFlow and PyTorch.
%
This is more than proof of concept,
as Ascent recently utilized a distributed-memory Random Forest.
%
\S\ref{sec:DevilRay} describes a success story regarding integrating
code,
namely incorporating the DevilRay code for ray-tracing higher order
elements.
%
Moving to another approach, Ascent has embraced analysis alongside
visualization.
%
Noteworthy analysis examples include simulated radiographs and its
query infrastructure to get quantitative results such as volumes,
surfaces areas, and integrated quantities.
%
Of course, Ascent supports typical visualization algorithms, such as
slicing, isosurfacing, volume rendering, and multiple plot types.
%
With respect to algorithms specifically for in situ processing, Ascent
has a significant investment in its ``trigger'' system~\cite{Larsen:ISAV18},
which adapts when visualization and analysis routines are executed,
based on the conditions in the system.
%
Ascent also has algorithms for extracting reduced forms of the data,
such as a module for extracting Lagrangian flow~\cite{Agranovsky:LDAV2014,Sane:EGPGV19} and the
aforementioned Cinema output.
%
Finally, Ascent has been designed from the beginning with modern
supercomputers in mind.
%
Especially because of the integration of VTK-m, Ascent is able to
run efficiently on these architectures.

The remainder of this chapter focuses on key elements of Ascent:
\begin{itemize}
\item \S\ref{sec:capabilities} discusses the key abstractions for using Ascent.
\item \S\ref{sec:design} discusses Ascent's design.
\item \S\ref{sec:API} discusses Ascent's APIs for sharing simulation
data and for controlling execution.
\item \S\ref{sec:success} discusses success stories using Ascent.
\end{itemize}

\section{Key Abstractions for Ascent --- Matt}
\label{sec:capabilities}
\input{ascent_does_stuff}

\section{System Architecture --- Matt}
\label{sec:design}
\input{system_architecture}

\section{Ascent APIs --- Hank}
\label{sec:API}

\section{Success Stories --- Matt}
\label{sec:success}
\input{successes}

\subsection{Devil Ray Rendering}
\label{sec:DevilRay}
\input{devil_ray}

\fix{EVERYTHING BELOW THIS POINT IS CURRENTLY ORPHANED.  AUTHORS
SHOULD PULL INFORMATION FROM THE BELOW AS THEY POPULATE THE SECTIONS
ABOVE.}


\if 0
Statement about capabilities.  Emphasis on being an integrator.
This is where Jupyter, triggers, etc. get mentioned.  Also emphasize
exascale.
Ascent has a rich feature set and integrates with other ecosystems.

\begin{itemize}
  \item Supports common visualization operations such as slicing and dicing your data.
  \item Supports ray traced surface and volume rendering as well as simulated radiography.
  \item Supports Queries for getting quantitative answers to questions
  \item Supports Triggers for adaptive visualization and analysis
  \item Outputs images sequences and Cinema image databases
  \item Outputs extracts for exporting data to HDF5, ADIOS, Python and Jupyter
  \item Support interactive visualization and analysis with Jupyter and Catalyst
  \item Supports C/C++, Python and Fortran language bindings
\end{itemize}

Statement about Devil Ray, but a forward reference a section in success stories --- success as an integrator.
\fi


\section{The Ascent In Situ Infrastructure}
\label{ascent_overview}
%Use the template \emph{chapter.tex} together with the document class SVMono (monograph-type books) or SVMult (edited books) to style the various elements of your chapter content conformable to the Springer Nature layout.

%List how ascent makes things easy.

\section{Design Considerations}
\label{ascent_design_considerations}
\input{design_considerations}


\section{Data Interface}
\label{ascent_data}
\input{data_interface}

\section{Control Interface}
\label{ascent_control}
\input{control_interface}

\section{Success Stories}
\label{ascent_success}
